> How the DBMS manages its memory and move data back-and-forth from disk
> 

**操作系统对于内存和数据的管理**

数据库的数据管理可以划分为两大块：

1. 空间控制：
    1. 将页写到磁盘上的哪个位置
    2. 目标是将经常一起使用的页保存在磁盘上尽可能靠近的位置
2. 时间控制：
    1. 何时将页读入内存中，何时将内存中的数据写入到磁盘上
    2. 目标是最小化必须从磁盘上读取数据带来的停顿

通俗得来讲，磁盘是计算机硬件里空间大但是访问速度慢的一个设备，而缓冲池（`buffer pool`）代表的是经常与用户进行交互的内存层次。内存和磁盘进行数据间的交互通常是这样发生的：比如说磁盘上有5页，编号分别为1、2、3、4、5，而这时用户态程序想要读取第二页的数据，因为起初缓冲池里没有第二页，因此缓冲池必须从磁盘上读取第二页—**先获取磁盘的目录，再根据目录获取第二页**

解释图大致如下：

![image1](/image/lecture5/1.png)

本节课的主要内容：

1. 缓冲池管理器
2. 替换政策
3. 其他的缓冲池

**缓冲池管理器：**

缓冲池的组成层次：

内存区域由有着固定页数大小的数组组织而成，数组的入口被称为**帧。**当DBMS需要某一页时，该页的一个复制会被放到其中的一个帧里。页表关注着当前在内存里的页，即建立了一个映射关系（类似于虚拟地址与物理地址之间）

解释图：

![image2](/image/lecture5/2.png)

**#tricky**锁和门锁（从数据库的层面）：

锁：

1. 保护数据库的逻辑内容不受其它事务的影响
2. 在一个事务进行时需要被拿到
3. 需要能够回滚进行更改

门锁：

1. 保护DBMS的重要部分的内部数据结构体不受其它线程的影响
2. 在操作的过程中被拿到
3. 不需要进行回滚更改

（更像一个互斥锁）

页目录：数据库文件里页的id和页的实际位置的映射关系

→所有的改变必须记录在磁盘里，以便数据库在重启时能够找到

页表：页id到页在缓冲池里的复制品的映射关系

→这是内存里的数据结构，不需要存储在硬盘中

**缓冲池的优化：**

1. 多个缓冲池：可以帮助减少门锁之间的竞争并且提升专用性（如果有独特的查询或者数据库或者页面的类型，都可以单独实例化一个缓冲池）
    
    多个缓冲池带来的问题：当多个缓冲池里有相同的页，查询时如何进行选择？
    
    第一种方法：对象id 在每个对象里插入一个id
    
    第二种方法：将页id散列（hash）
    
2. 预取
3. 扫描共享：扫描可以复用从存储仓库里取回的数据或者算子计算
    
    →也被称为同步扫描：允许多个查询拥有自己的光标上来扫描一个表，所以可以同时进行多个查询并且可以分享中间结果
    
    →当有多个光标进行扫描时，后加入的光标可以直接附着到已经扫描了一部分页的光标上，相当于利用了中间结果（但是在加入的过程中之前的扫描必须进行等待）
    
4. 缓冲池绕过：顺序扫描运算符不会存储从缓冲池里获取的页以避免开销
    
    →内存是运行查询的本地内存
    
    →在运算符需要读取大量的连续分布在磁盘上的页是有很好的效果
    
    →可以用于临时数据
    

缓冲池的替换政策：

**LRU**

LRU机制存在的问题：对于落地顺序扫描太过于易受影响

→落地顺序扫描会因为有可能要只读取一此一个之后不会再被使用的页面而污染整个缓冲池

在某些工作负载下，最经常使用的页面是最不需要的页面

比LRU更好的替换政策：

1. **LRU-K：**对每个页面之前的k个引用进行跟踪来作为时间戳并且计算在之后的访问中的中间态，DBMS使用这些历史来评估页面下一次被访问会是什么时候
2. 本地化（localization）：DBMS在单个查询的基础下去选择哪个页面需要被驱逐，这最小化了每个查询给缓冲池带来的污染
3. 优先级提示：DBMS在每次执行时都知道每个页面的上下文，它可以给缓冲池提示什么页面重要而什么页面不重要